import numpy as np

class GNAR_simulator:
    def __init__(self, N = 100, T = 300, G = 5, seed = 42, network_time_varying = False, CV_time_varying = False, CV_len = 4, omit_eye = True, network_dummy = True):
        """ Initialize the GNAR simulator with parameters  
        N = 100: Number of nodes.   
        T = 300: Number of time points    
        G = 5: Number of groups    
        seed = 42: Random seed for reproducibility    
        network_time_varying = False: Whether the network is time-varying   
        CV_time_varying = False: Whether the CV is time-varying  
        CV_len = 4: Length of the CV vector   
        omit_eye = True: Whether to omit the diagonal elements of the network  
        network_dummy = True: Whether to use a dummy network (0 or 1)
        """
        np.random.seed(seed)
        self.N = N
        self.T = T
        self.G = G
        self.p = CV_len
        self.network_time_varying = network_time_varying
        self.CV_time_varying = CV_time_varying
        self.omit_eye = omit_eye
        self.network_dummy = network_dummy
    
    def generate_para(self, beta=None, v=None, gamma=None):
        """ Generate the parameters for the GNAR model  
        return:  
        beta: G*G的网络系数矩阵    
        v: G个动量系数    
        gamma: G*p的CV系数矩阵   
        group: N个节点的分组，取值范围为0到G-1
        """
        # 随机生成初始数据 长度为N array
        self.y0 = np.random.rand(self.N)
        # 如果网络时间变化，生成一个随机的网络连接矩阵
        if self.network_time_varying:
            self.network = np.random.rand(self.N, self.N, self.T)
        else:
            self.network = np.random.rand(self.N, self.N)
            self.network = np.repeat(self.network[:, :, np.newaxis], self.T, axis=2)
        # 只保留网络的大于0.5的部分
        self.network[self.network < 0.5] = 0
        # 如果network_dummy为True，则将网络的非0部分置为1
        if self.network_dummy:
            self.network[self.network > 0] = 1
        # 如果omit_eye为True，则将网络的前两个维度的对角线元素置为0
        if self.omit_eye:
            for t in range(self.T):
                np.fill_diagonal(self.network[:, :, t], 0)
        # 网络的任何【i，：】和为1
        self.network = self.network / np.sum(self.network, axis=1, keepdims=True)
        if gamma is None:
            # 生成G*p个CV系数
            self.gamma = np.random.uniform(-1, 1, (self.G, self.p))
        else:
            # 如果gamma不为None，则使用传入的参数
            self.gamma = gamma
            self.p = gamma.shape[1]
        # 如果CV时间变化，生成一个随机的CV矩阵
        if self.CV_time_varying:
            self.CV = np.random.rand(self.N, self.p, self.T)
        else:
            self.CV = np.random.rand(self.N, self.p)
            self.CV = np.repeat(self.CV[:, :, np.newaxis], self.T, axis=2)
        # 生成一个独立分布的噪声矩阵，正态分布，sigma为0.005
        self.eps = np.random.normal(0, 0.005, (self.N, self.T))
        if (beta is None) and (v is None):
            # 生成随机的G个动量系数，取值范围【0.2，0.9】
            self.v = np.random.uniform(0.2, 0.9, self.G)
            # 生成随机的G*G个Network系数，取值范围【0，0.4】
            self.beta = np.random.uniform(0, 0.4, (self.G, self.G))
            # 保证真实系数条件的成立
            sum_ = np.max(self.beta, axis=0) + self.v + np.random.uniform(0.05, 0.2, self.G)
            self.beta = self.beta / sum_
            self.v = self.v / sum_
        elif (beta is not None) and (v is not None):
            # 如果beta和v不为None，则使用传入的参数
            self.beta = beta
            self.v = v
        else:
            raise ValueError("Both beta and v must be None or both must be provided.")
        # 生成分组，将N个节点分成G组
        self.group = np.random.randint(0, self.G, self.N)
        return self.beta, self.v, self.gamma, self.group

    def generate_data(self):
        """ Generate the data based on the parameters generated by generate_para  
        return:  
        Y: N*T的矩阵，表示每个节点在每个时间点的值   
        CV: N*p*T的矩阵，表示每个节点在每个时间点的CV值   
        network: N*N*T的矩阵，表示每个节点在每个时间点的网络连接情况，网络已经归一化处理过    
        """
        #按照N个节点对应的组，构建N*N的系数矩阵，其中i，j节点的系数为beta[group[i], group[j]]
        self.coef = np.zeros((self.N, self.N))
        for i in range(self.N):
            for j in range(self.N):
                self.coef[i, j] = self.beta[self.group[i], self.group[j]]
        # 按照N个节点对应的组，把G个动量系数v构建长度为N的动量系数
        self.v_coef = np.zeros(self.N)
        for i in range(self.N):
            self.v_coef[i] = self.v[self.group[i]]
        # 按照N个节点对应的组，把G*p个CV系数gamma构建N*p的CV系数
        self.gamma_coef = np.zeros((self.N, self.p))
        for i in range(self.N):
            self.gamma_coef[i, :] = self.gamma[self.group[i], :]
        # 将N*N*T的network矩阵与系数矩阵相乘，得到N*N*T的网络系数矩阵
        self.network_coef = np.zeros((self.N, self.N, self.T))
        for t in range(self.T):
            self.network_coef[:, :, t] = self.network[:, :, t] * self.coef
        # 递推每一天的 Yt = v@Yt-1 + network_coef@Yt-1 + gamma@CV + eps，注意是矩阵乘法
        self.Y = np.zeros((self.N, self.T))
        self.Y[:, 0] = self.y0
        for t in range(1, self.T):
            # 计算上一天的Yt-1
            Y_prev = self.Y[:, t-1]
            # 计算动量部分
            momentum = self.v_coef * Y_prev
            # 计算网络部分
            network_part = self.network_coef[:, :, t-1] @ Y_prev
            # 计算CV部分（先乘再求和）
            CV_part = np.sum(self.gamma_coef * self.CV[:, :, t-1], axis=1)
            # 计算噪声部分
            noise = self.eps[:, t]
            # 计算当天的Yt
            self.Y[:, t] = momentum + network_part + CV_part + noise
        return self.Y, self.CV, self.network

            